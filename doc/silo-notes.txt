----
Tianzheng's notes on Silo.
----

dbtest.cc:
    main function

benchmarks/[benchmark_name].cc includes implementation of the benchmark. Inside
it the function "[benchmark_name]_do_test" is the main function for executing
this benchmark.

Parameters for specific a benchmark is specified at command line by "-o xxx".

bench.cc:
    General benchmark execution code. in benchmarks/[benchmark_name].cc a class
    called "[benchmark_name]_bench_runner" is defined. It inherits a generic
    class called "bench_runner" in this file. This class in turn invokes the
    specific benchmark's functions that overrides the corresponding virtual
    functions in the bench_runner class.

    bench_runner creates a bunch bench_workers, which is inherited by the
    corresponding benchmark, e.g., tpcc_bench_worker. Then bench_worker::run()
    will invoke functions provided by the corresponding benchmark, e.g.,
    get_workload(), which is overriden by specific benchmarks.

----
Logging
----
How does a transaction insert log records?
1. Call path (tpcc payment as an example)
   tpcc_worker::txn_payment() -> ndb-wrapper->commit_txn() ->
   transaction::commit() -> transaction_proto2::on_tid_finish().

   on_tid_finish() is where a committing transaction will write its tuples
   to the log buffer. Inside on_tid_finish(), txn_logger::persist_ctx_for()
   gets the log buffer etc., and then write_current_txn_into_buffer() does
   the real work to write data to the log buffer.

   txn_logger::persist_ctx - encapsulates a commiting transaction, with
   log buffers etc. defined in it.

2. write_current_txn_into_buffer() uses transaction_base::write_record_t
   to represent record/tuple, one for each element in the write set. The
   write_record_t struct also includes a tuple_writer, which writes the
   tuple to the log buffer, which is obtained as a function parameter,
   which is passed by on_tid_finish() and is actually the circular buf
   in the ctx returned by persist_ctx_for().

How are log buffers destaged?
1. There're one (or more) "txn_logger::writer" thread per core, and
   one txn_logger::persister thread. Both just run as infinite loop all the
   time to help persist log records.

2. txn_logger::persister seems only advances epochs

3. Each txn_logger::writer looks at its txn's persist_ctx structs got using
   persist_ctx_for(), which is the sameone that was used by on_tid_finish(),
   i.e., the one used when the tx commits and writes to log buffer.

